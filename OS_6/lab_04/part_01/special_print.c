#include <stdio.h>
#include <string.h>

#include "special_print.h"


char *stat_field_names[] = {
	"pid",	// %d Идентификатор процесса.
	"comm", // %s Имя исполняемого файла в круглых скобках.
	// Состояния:
	// R -- запущен,
	// S -- процесс "спит" в прерываемом ожидании,
	// D -- процесс ожидает в непрерываемом состоянии окончания дисковой операции,
	// Z -- процесс является зомби, или же
	// T -- процесс трассируется или остановлен (по сигналу) и
	// W -- процесс вызывается.
	"state",	   // %c Состояние процесса.
	"ppid",		   // %d Идентификатор (PID) родительского процесса.
	"pgrp",		   // %d Идентификатор группы процесса.
	"session",	   // %d Идентификатор сессии процесса.
	"tty_nr",	   // %d Терминал tty, который использует процесс.
	"tpgid",	   // %d Идентификатор группы процесса, который в настоящий момент владеет терминалом tty, к которому подключен данный процесс.
	"flags",	   // %lu Флаги процесса. Матеметический бит -- десятичное 4, бит трассировки -- десятичное 10.
	"minflt",	   // %lu Количество незначительных сбоев, которые возникли при работе процесса, и которые не требуют загрузки страницы памяти с диска.
	"cminflt",	   // %lu Количество незначительных сбоев, которые возникли при ожидании окончания работы процессов-потомков.
	"majflt",	   // %lu Количество значительных сбоев, которые возникли при работе процесса, и которые потребовали загрузки страницы памяти с диска.
	"cmajflt",	   // %lu Количество значительных сбоев, которые возникли при ожидании окончания работы процессов-потомков.
	"utime",	   // %lu Количество тиков (jiffies), которые получил процесс, выполняющийся в режиме пользователя.
	"stime",	   // %lu Количество тиков, которые данный процесс провел в режиме ядра.
	"cutime",	   // %ld Количество тиков, которые данный процесс и его потомки провели в режиме пользователя. (См. также times(2).)
	"cstime",	   // %ld Количество тиков, которые процесс, ожидающий завершения процессов-потомков, провёл в режиме ядра.
	"priority",	   // %ld Стандартная величина приоритета (для nice) плюс 15. Данное значение в ядре никогда не бывает отрицательным.
	"nice",		   // %ld Значение для nice в диапазоне от 19 (наиболее низкий приоритет) до -19 (наивысший приоритет).
	"num_threads", // Количество потоков
	"itrealvalue", // %ld Время (в тиках) перед следующей посылкой процессу SIGALRM из-за внутреннего таймера.
	"starttime",   // %lu Время (в тиках) запуска процесса после начальной загрузки системы.
	"vsize",	   // %lu Размер виртуальной памяти в байтах.
	// Резидентный Размер: количество страниц, которые занимает процесс в реальной памяти,
	//  минус 3 для административных целей. Это те страницы, которые заняты кодом, данными
	// и пространством стека. Сюда не включаются страницы, которые не были загружены
	// по требованию или которые находятся в своппинге.
	"rss",		   // %ld Resident Set Size: Количество страниц процесса в физической памяти.
	"rlim",		   // %lu Текущий лимит в байтах на резидентный размер процесса (обычно 4294967295 на i386).
	"startcode",   // %lu Адрес, выше которого может выполняться код программы.
	"endcode",	   // %lu Адрес, ниже которого может выполняться код программ.
	"startstack",  // %lu Адрес начала стека.
	"kstkesp",	   // %lu Текущее значение esp (указателя стека) для данного процесса, которое следует из страницы стека в ядре.
	"kstkeip",	   // %lu Текущее значение EIP (instruction pointer) (указатель инструкций).
	"signal",	   // %lu Карта ожидающих сигналов (обычно 0).
	"blocked",	   // %lu Карта блокированных сигналов (обычно 0, или 2 для командных интерпретаторов).
	"sigignore",   // %lu Карта игнорируемых сигналов.
	"sigcatch",	   // %lu Карта перехваченных сигналов.
	"wchan",	   // %lu Это "канал", в котором ожидает процесс.
	"nswap",	   // %lu Количество страниц на своппинге - не обслуживается.
	"cnswap",	   // %lu Суммарное nswap для процессов-потомков.
	"exit_signal", // %d Сигнал, который будет послан родителю, когда процесс умрёт.
	"processor"	   // %d Номер процессора, на котором последний раз выполнялся процесс.
};

int stat_print(const char *buf, FILE *out_file, const char *title)
{
	fprintf(out_file, "\n                                %s\n", title);
	int i = 0;
	char *istr = strtok(buf, " ");

	while (istr != NULL && i < 37)
	{
		fprintf(out_file, "%-16s %-16s\n", stat_field_names[i++], istr);
		istr = strtok(NULL, " ");
	}
	return 0;
}
