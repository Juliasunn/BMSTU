Makefile: 
obj-m - список модулей ядра для сборки

uname - print system information
  -r, --kernel-release
              print the kernel release
$(shell uname -r) - определение ОС в  makefile
-C - опция смены каталога на тот путь к котрому указан после

M=$(shell pwd) - заставляет Makefile вернуться обрано в директорию исх. кодов модулей (в lab_03 md1, md2, ...)


терминал:
sudo insmod [module_name].ko - загрузка модуля ядра
sudo lssmod - просмотр модулей ядра
sudo rmmod [module_name].ko - выгрузка модуля ядра

(!) надо insmod-ить сначала md1 потом md3 так как EXPORT_SYMBOL() из md1.
sudo dmesg - вывод содержимого файла системного журнала /var/sys/log, куда пишем системным вызовом printk()

в коде:
EXPORT_SYMBOL()  - предоставляет API данного модуля другим модулям.
функции и переменные которые EXPORT доступны в других модулях/коде.


Из книжки Цирюлиха:
                                         Взаимодействие МОДУЛЯ с уровнем ЯДРА
Для взаимодействия модуля с ядром, ядро (и подгружаемые к ядру модули) экспортируют набор имён,
которые новый модуль использует в качестве API ядра.

Вызовы API ядра осуществляются по прямому абсолютному адресу. Каждому ЭКСПОРТИРОВАННОМУ ядром
или любым модулем ИМЕНИ СООТНОСИТСЯ АДРЕС, он и ИСПОЛЬЗУЕТСЯ для связывания при загрузке модуля,
использующего это имя. Это основной механизм взаимодействия модуля с ядром.

Динамически формируемый (после загрузки) список имён ядра находится в файле /proc/kallsyms.

Все известные имена ядра мы можем получить: $ awk '/T/ && /print/ { print $0 }' /proc/kallsyms


                                          Взаимодействие МОДУЛЯ с уровнем ПОЛЬЗОВАТЕЛЯ
Для взаимодействия с уровнем пользователя (командами, приложениями, системными файлами, внешними устройствами...) у модуля есть много способов взаимодействия.    

1) 1. Диагностика из модуля (в системный журнал)  системный вызов printk()  

– осуществляет вывод в текстовую консоль (не графический терминал!);
– осуществляет вывод в файл журнала /var/log/messages ;
– содержимое файла журнала можно дополнительно посмотреть командой dmesg;

2)  Копирование данных в программном коде между пользовательским адресным пространством и
пространством ядра (выполняется только по инициативе модуля). Выполняется вызовами API ядра put_user, get_user, copy_to_user, copy_from_user,
которые предназначены для обмена данными между адресным пространством ядра и пространством пользователя. 

3) Интерфейс взаимодействия посредством создания символьных имён устройств, вида /dev/XXX.
Модуль может обеспечивать поддержку стандартных операций ввода-вывода на устройстве (как символьном,
там и блочном). Это основной интерфейс модуля к пользовательскому уровню. 

4) Взаимодействие через файлы (имена) системы /proc (файловая система procfs). Модуль может
создавать специфические для него индикативные псевдофайлы в /proc, туда модуль может писать отладочную
или диагностическую информацию, или читать оттуда управляющую. Эти файлы в /proc доступны для чтения-
записи всеми стандартными командами Linux (в пределах регламента прав доступа, установленных для
конкретного файлового имени).   

5) Взаимодействие через файлы (имена) системы /sys (файловая система sysfs). Эта файловая система
подобна (по назначению) /proc, но возникла заметно позже, считается, что её функциональность выше, и она
во многих качествах будет заменять /proc. Будет детально рассмотрено далее.

6) Взаимодействие модуля со стеком сетевых протоколов 

                                         ЗАГРУЗКА МОДУЛЯ
Утилита insmod получает имя файла модуля, и пытается загрузить его без проверок взаимосвязей, если обнаруживает неразрешённое имя — завершает загрузку аварийно.

Утилита rmmod выгружает ранее загруженный модуль, в качестве параметра утилита должна получать
имя модуля (не имя файла модуля). Если в системе есть модули, зависимые от выгружаемого (счётчик ссылок
использования модуля больше нуля), то выгрузка модуля не произойдёт, и утилита rmmod завершится аварийно. 
          
                                                              ЛАБА 1 ЧАСТЬ
Множество процессов в Linux - это совокупность структур struct task_struct, которые взаимосвязаны двумя способами. 
как хеш-массив, хешированный по pid,
 и как кольцевой двусвязный список, в котором элементы ссылаются друг на друга посредством указателей p->next_task и p->prev_task.  
                                                       
Для прохождения всего списка задач, в системе предусмотрен макрос for_each_task()
 #define for_each_task(p) \ for (p = &init_task ; (p = p->next_task) != &init_task ; ) 
 
 Структура task_struct объявлена в include/linux/sched.h                                                         
